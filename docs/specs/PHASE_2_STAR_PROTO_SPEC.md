# Phase 2 Specification: The Star Protocol & Agent

**Status:** DRAFT
**Target Version:** v0.6.0-alpha.2
**Prerequisites:** Phase 1 (Abstraction Layer)

## 1. Executive Summary

Phase 2 builds the Orbit Grid's nervous system. We will define the gRPC contract (`orbit.proto`) that allows the Nucleus (Hub) to control Stars (Agents). We will then implement the `orbit-star` binary: a lightweight, stateless server that exposes the local filesystem and CPU to the Grid.

- **The Contract:** `crates/orbit-proto` (Shared types).
- **The Agent:** `crates/orbit-star` (The remote execution binary).
- **The Goal:** A running Star that can receive a "Hash This File" command from grpcurl.

## 2. Architecture: The orbit.proto Contract

We define the service methods to mirror the `OrbitSystem` trait from Phase 1. This ensures that a remote call looks identical to a local call from the perspective of the business logic.

### 2.1 Crate Definition

- **Crate:** `crates/orbit-proto`
- **Dependencies:** `tonic`, `prost`, `tokio-stream`.
- **Build Script:** `build.rs` compiles the `.proto` file.

### 2.2 The Protocol Definition

**File:** `crates/orbit-proto/proto/orbit.proto`

```protobuf
syntax = "proto3";

package orbit.v1;

service StarService {
  // --- 1. Connection & Auth ---
  // Establishes identity and capabilities.
  rpc Handshake (HandshakeRequest) returns (HandshakeResponse);

  // --- 2. Discovery ---
  // Lists files in a directory. Returns a stream to handle massive folders (1M+ files).
  rpc ScanDirectory (ScanRequest) returns (stream FileEntry);

  // --- 3. Intelligence ---
  // Reads the first N bytes for semantic analysis (magic numbers).
  rpc ReadHeader (ReadHeaderRequest) returns (ReadHeaderResponse);

  // --- 4. Compute (CDC) ---
  // The Heavy Lifter: Hashes a file range on the remote CPU.
  rpc CalculateHash (HashRequest) returns (HashResponse);
}

// --- Message Types ---

message HandshakeRequest {
  string star_token = 1;       // The "Join Token" generated by Nucleus
  string version = 2;          // Agent version (e.g., "0.6.0")
  repeated string capabilities = 3; // ["zstd", "avx2", "gpu"]
}

message HandshakeResponse {
  bool accepted = 1;
  string session_id = 2;
  string nucleus_version = 3;
}

message ScanRequest {
  string path = 1;
}

message FileEntry {
  string name = 1;
  uint64 size = 2;
  bool is_dir = 3;
  uint64 modified_at_ts = 4; // Unix Timestamp
  // Note: Full path is inferred from request + name
}

message ReadHeaderRequest {
  string path = 1;
  uint32 length = 2;
}

message ReadHeaderResponse {
  bytes data = 1;
}

message HashRequest {
  string path = 1;
  uint64 offset = 2;
  uint64 length = 3;
}

message HashResponse {
  bytes hash = 1; // 32 bytes (BLAKE3)
}
```

## 3. Implementation: The orbit-star Binary

This is the new executable that runs on the remote NAS or File Server. It is designed to be "install-and-forget."

### 3.1 Crate Structure

- **Crate:** `crates/orbit-star`
- **Dependencies:**
  - `orbit-proto` (The interface)
  - `orbit-core-cdc` (For hashing)
  - `tonic` (gRPC Server)
  - `tokio` (Runtime)
  - `clap` (CLI Args)
  - `anyhow` (Error handling)

### 3.2 Security: The Jail (Path Sanitation)

The Star MUST NOT expose the entire OS. It must be sandboxed to specific allowed paths.

```rust
// crates/orbit-star/src/security.rs

use std::path::{Path, PathBuf};
use anyhow::{bail, Result};

pub struct PathJail {
    allowed_roots: Vec<PathBuf>,
}

impl PathJail {
    pub fn new(roots: Vec<PathBuf>) -> Self {
        Self {
            // Canonicalize roots to resolve symlinks immediately
            allowed_roots: roots.into_iter().filter_map(|p| p.canonicalize().ok()).collect(),
        }
    }

    /// Verifies that a requested path is inside one of the allowed roots.
    /// Prevents directory traversal attacks (../../etc/passwd).
    pub fn secure_path(&self, requested: &str) -> Result<PathBuf> {
        // 1. Prevent absolute paths that aren't rooted (if client sends "/etc/shadow")
        // 2. Canonicalize the requested path
        let path = Path::new(requested);

        // Simple check: iterate roots and check starts_with
        // Real impl needs careful handling of ".." components before canonicalization
        // or strictly joining with a root.

        // For MVP: We assume requests are relative to a logical mount point
        // or we check absolute paths against the whitelist.
        // ... implementation details ...
        Ok(secure_path)
    }
}
```

### 3.3 Service Implementation (StarImpl)

This struct implements the generated `StarService` trait. It effectively maps gRPC calls to `std::fs` calls (using the LocalSystem logic we identified in Phase 1).

```rust
// crates/orbit-star/src/server.rs

use orbit_proto::star_service_server::StarService;
use orbit_proto::{HashRequest, HashResponse, ...};
use tonic::{Request, Response, Status};
use crate::security::PathJail;

pub struct StarImpl {
    jail: PathJail,
}

#[tonic::async_trait]
impl StarService for StarImpl {
    async fn calculate_hash(
        &self,
        request: Request<HashRequest>,
    ) -> Result<Response<HashResponse>, Status> {
        let req = request.into_inner();

        // 1. Security Check
        let path = self.jail.secure_path(&req.path)
            .map_err(|e| Status::permission_denied(e.to_string()))?;

        // 2. Execute Logic (CPU Intensive - spawn blocking?)
        // Reuse orbit_core_cdc::hash_file_range
        let hash = orbit_core_cdc::hash_file_range(&path, req.offset, req.length)
            .await
            .map_err(|e| Status::internal(e.to_string()))?;

        // 3. Respond
        Ok(Response::new(HashResponse {
            hash: hash.to_vec(),
        }))
    }

    async fn scan_directory(
        &self,
        request: Request<ScanRequest>,
    ) -> Result<Response<Self::ScanDirectoryStream>, Status> {
        // Use tokio_stream::wrappers::ReceiverStream
        // Spawn a thread to walk the directory and send items to the channel
        // ...
    }

    // ... Implement Handshake and ReadHeader ...
}
```

### 3.4 The Main Entry Point

```rust
// crates/orbit-star/src/main.rs

#[tokio::main]
async fn main() -> Result<()> {
    let args = Cli::parse(); // --port 50051 --token SECRET --allow /mnt/data

    let addr = format!("0.0.0.0:{}", args.port).parse()?;
    let star = StarImpl::new(args.allow_paths);

    println!("âœ¨ Orbit Star listening on {}", addr);

    Server::builder()
        // Optional: Add Interceptor for Token Validation here
        .add_service(StarServiceServer::new(star))
        .serve(addr)
        .await?;

    Ok(())
}
```

## 4. Operational Guide

### 4.1 Running the Star

```bash
# Start the agent on the remote machine
orbit-star --port 50051 --allow /data/backups --token "secret-join-token"
```

### 4.2 Verifying with grpcurl

You can test the Star without the Hub using generic gRPC tools.

```bash
# Check Health/Handshake
grpcurl -plaintext -d '{"star_token": "secret-join-token"}' \
    localhost:50051 orbit.v1.StarService/Handshake

# Calculate a Hash remotely
grpcurl -plaintext -d '{"path": "/data/backups/large.iso", "offset": 0, "length": 1048576}' \
    localhost:50051 orbit.v1.StarService/CalculateHash
```

## 5. Security Detail: The Handshake

For Phase 2, we will implement **Token Authentication**.

1. Nucleus generates a random string (`ORBIT_AUTH_SECRET`).
2. Star is started with this string.
3. **Handshake:** The first request from Nucleus to Star sends this token.
4. **Session:** If valid, the Star returns a `session_id`. Future requests (Scan, Hash) must include this `session_id` in metadata (headers), or the Star will reject them.

**Implementation Note:** Tonic Interceptors are the best place to enforce this check efficiently.

## 6. Deliverables Checklist

- [ ] Crate Created: `crates/orbit-proto` with `build.rs`.
- [ ] Schema Defined: `proto/orbit.proto` matches spec.
- [ ] Binary Created: `crates/orbit-star` compiles.
- [ ] Functionality: `CalculateHash` works and returns correct BLAKE3 hash.
- [ ] Security: `PathJail` successfully blocks access to `/etc/passwd`.
- [ ] CI: Added to workspace and GitHub Actions.

## 7. Next Steps (Lookahead to Phase 3)

Once Phase 2 is complete, we will have a "Brain" (Nucleus) and a "Hand" (Star), but they won't be connected.

**Phase 3:** We will implement `RemoteSystem` in the Nucleus. This struct will hold a `tonic::transport::Channel` and implement the `OrbitSystem` trait (from Phase 1) by making gRPC calls to the Star (from Phase 2).
